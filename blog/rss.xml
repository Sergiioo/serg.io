<?xml version='1.0' encoding='UTF-8'?><rss xmlns:atom='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/' xmlns:georss='http://www.georss.org/georss' version='2.0'><channel><atom:id>tag:blogger.com,1999:blog-4414172998613045683</atom:id><lastBuildDate>Fri, 06 Mar 2009 22:09:57 +0000</lastBuildDate><title>serg.io</title><description>infrequent ramblings</description><link>http://serg.io/blog/</link><managingEditor>noreply@blogger.com (Sergio)</managingEditor><generator>Blogger</generator><openSearch:totalResults>7</openSearch:totalResults><openSearch:startIndex>1</openSearch:startIndex><openSearch:itemsPerPage>25</openSearch:itemsPerPage><item><guid isPermaLink='false'>tag:blogger.com,1999:blog-4414172998613045683.post-241043496984854559</guid><pubDate>Thu, 28 Aug 2008 19:02:00 +0000</pubDate><atom:updated>2008-08-29T21:25:30.165+01:00</atom:updated><title>Generics in Java are not so bad.  Stop your moaning!</title><description>&lt;p&gt;It seems a commonly held belief that due to &lt;a href="http://java.sun.com/docs/books/tutorial/java/generics/erasure.html"&gt;type erasure&lt;/a&gt;, Java's implementation of generics is somehow tainted.  I mean, it is &lt;strong&gt;just&lt;/strong&gt; compiler magic right?  The comparison with the .net languages is a frequent one.  Having generic type information availble at runtime certainly has benefits in that reflection works and the .net CLR is able to make more optimisations by avoiding the casting / boxing overheads.&lt;br /&gt;&lt;br /&gt;The argument for Sun's decision to go with type erasure - backwards compatibility - is well appreciated.  However, I didn't realise until recently that generics were bolted onto .net after the initial release.  Obviously Microsoft didn't wait as long as Sun did, but they were definitely not there from the outset.  So, all of the same compatibility problems that Java suffered applies to net too.  But, as Microsoft opted for the non-backwardsly compatible route and allowed reifiable types, they essentially deprecated all of the existing library classes that work with non-generic types.&lt;br /&gt;&lt;br /&gt;Which in many ways seems like a real shame.  From a purely aesthetic point of view, C# is a very elegant language that neatly avoids a lot of Java's legacy &lt;a href="http://java.sun.com/docs/books/tutorial/java/nutsandbolts/datatypes.html"&gt;cruft&lt;/a&gt;.  What a shame to have a whole package of non-generic collections classes sitting in the background like a wart on the core API.  And so early on in the language's lifetime.&lt;br /&gt;&lt;br /&gt;Here's another example.  As Enum already existed in C#, it could not be generic-afied (pretty sure that is not a verb...) without breaking all existing usages.  So Enum in C# does not have a crazy looking definition like in Java:&lt;br /&gt;&lt;br /&gt;&lt;pre class="codeBlock"&gt;&lt;br /&gt;public abstract class Enum&amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; &lt;br /&gt;extends Object implements Comparable&amp;lt;E&amp;gt;, Serializable&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;(Angelika Langer has the &lt;a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/TypeParameters.html#How%20do%20I%20decrypt%20Enum?"&gt;best explanation &lt;/a&gt;of this initially baffling splurge of brackets.&lt;br /&gt;&lt;br /&gt;Which means that parsing a String to an enum value cannot be done in a typesafe way, and takes some hoop jumping in C#:&lt;br /&gt;&lt;br /&gt;&lt;pre class="codeBlock"&gt;&lt;br /&gt;//  Parsing String to Enum in C#&lt;br /&gt;Colour colour = (Colour)Enum.Parse(typeof(Colour), "RED");&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;Compare this to the elegant version possible with Java's api:&lt;br /&gt;&lt;pre class="codeBlock"&gt;&lt;br /&gt;//  Parsing String to Enum in Java&lt;br /&gt;Colour colour = Colour.valueOf("RED");&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;It feels like a missed opportunity.  The brave decision was to break backwards compatibility for the sake of a purist and better functioning approach to generics.  Pity then to sidestep the controversy by not applying this to all of the existing libraries - C# is already saddled with crufty code in its core libraries.&lt;br /&gt;&lt;/p&gt;</description><link>http://serg.io/blog/2008/08/generics-in-java-are-not-so-bad-stop.html</link><author>noreply@blogger.com (Sergio)</author><thr:total xmlns:thr='http://purl.org/syndication/thread/1.0'>0</thr:total></item><item><guid isPermaLink='false'>tag:blogger.com,1999:blog-4414172998613045683.post-1210739757921681089</guid><pubDate>Sat, 12 Jan 2008 22:00:00 +0000</pubDate><atom:updated>2008-01-12T23:01:51.897Z</atom:updated><category domain='http://www.blogger.com/atom/ns#'>java</category><category domain='http://www.blogger.com/atom/ns#'>style</category><title>New year's resolution - be concise, but not terse</title><description>&lt;p&gt;I've just finished Strunk and White's classic &lt;a href="http://books.google.co.uk/books?id=FyH_qs6CS4cC&amp;pgis=1"&gt;The Elements of Style&lt;/a&gt; which I strongly recommend.  It teaches you to review your writing before inflicting it on its readers.  The book is under 100 pages which proves the authors understand concise use of the language.  On top of that, it is an enjoyable little book to read.  In the same way, the brevity of your coded language is important.  Here's a great example from the Java api:&lt;br /&gt;&lt;pre class="codeBlock"&gt;Set&amp;lt;Colour&amp;gt; primaries = EnumSet.of(RED, BLUE, YELLOW);&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;There is something beautiful about the perfectly-named method "&lt;code&gt;of&lt;/code&gt;".  Since &lt;a href="http://books.google.co.uk/books?id=ZZOiqZQIbRMC"&gt;Effective Java&lt;/a&gt; we all know to favour static factory methods over constructors.  When dealing with generics it is even more important.  Until &lt;a href="http://serg.io/blog/2007/10/java-generics-and-constructor-type.html"&gt;constructor type inference&lt;/a&gt; arrives in Java, the constructor version would be comparatively cumbersome&lt;br /&gt;&lt;pre class="codeBlock"&gt;Set&amp;lt;Colour&amp;gt; primaries = new EnumSet&amp;lt;Colour&amp;gt;(RED, BLUE, YELLOW);&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;In some future generation of the language, an operator overloading could provide more terse code.  Maybe something like:&lt;br /&gt;&lt;pre class="codeBlock"&gt;EnumSet&amp;lt;Colour&amp;gt; primaries += {RED, BLUE, YELLOW};&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;I'd argue that the &lt;code&gt;of&lt;/code&gt; method is aesthetically more pleasing than the overloading.  That's the difference between being concise and terse.  Brief, clear and accurate, but not to the point of alienating those that have to read it.&lt;/p&gt;</description><link>http://serg.io/blog/2008/01/new-years-resolution-be-concise-but-not.html</link><author>noreply@blogger.com (Sergio)</author><thr:total xmlns:thr='http://purl.org/syndication/thread/1.0'>0</thr:total></item><item><guid isPermaLink='false'>tag:blogger.com,1999:blog-4414172998613045683.post-6419423514976435408</guid><pubDate>Fri, 16 Nov 2007 09:23:00 +0000</pubDate><atom:updated>2007-11-16T14:19:06.515Z</atom:updated><title>The obligatory shameless cross link self promotion blog entry...</title><description>&lt;p&gt;Check out my new &lt;a href="http://www.codingthearchitecture.com/2007/11/16/wheres_the_coffee_machine.html"&gt;mercifully short post&lt;/a&gt; on the codingthearchitecture blog.&lt;br /&gt;&lt;br/&gt;I recently told &lt;a href="http://www.simongbrown.com"&gt;Simon&lt;/a&gt; via &lt;a href="http://twitter.com/serg10/statuses/297297902"&gt;twitter&lt;/a&gt;* that I wouldn't call myself an architect until I posted on the codingthearchitecture blog.  He mocked me.  To be honest, I still do not know if I would use that term as in my experience it can sound a little standoffish.&lt;br /&gt;&lt;small&gt;* does the act of mocking someone on twitter have a verb - "twatter" maybe?&lt;/small&gt;&lt;/p&gt;</description><link>http://serg.io/blog/2007/11/obligatory-shameless-cross-link-self.html</link><author>noreply@blogger.com (Sergio)</author><thr:total xmlns:thr='http://purl.org/syndication/thread/1.0'>0</thr:total></item><item><guid isPermaLink='false'>tag:blogger.com,1999:blog-4414172998613045683.post-8591086565732437373</guid><pubDate>Sun, 07 Oct 2007 20:33:00 +0000</pubDate><atom:updated>2007-10-19T20:00:05.695+01:00</atom:updated><category domain='http://www.blogger.com/atom/ns#'>java generics</category><title>Java generics and constructor type inference</title><description>&lt;p&gt;I started thinking about this over a curry with some colleagues who had some strong opinions on Java's generics.  A lot of the &lt;a href="http://weblogs.java.net/blog/arnold/archive/2005/06/generics_consid_1.html"&gt;flack&lt;/a&gt; directed at generics in Java, and even at Java itself, relates to its apparent verbosity.  Take the classic example of instantiating a new Map.&lt;/p&gt;&lt;br /&gt;&lt;pre class="codeBlock"&gt;&lt;br /&gt;Map &amp;lt;Integer, String&amp;gt; crudeCache = new HashMap&amp;lt;Integer, String&amp;gt;();&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;Why are the type parameters declared twice?  Can't the compiler infer the types used in the call to the generic constructor from the reference declaration?  This has been asked before, and there are a &lt;a href="http://www.jroller.com/scolebourne/entry/java_7_short_declarations"&gt;few proposals&lt;/a&gt;, but Neal Gafter's &lt;a href="http://gafter.blogspot.com/2007/07/constructor-type-inference.html"&gt;recent post&lt;/a&gt; seems the slickest to me.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;He proposes this syntax&lt;/p&gt;&lt;br /&gt;&lt;pre class="codeBlock"&gt;&lt;br /&gt;Map &amp;lt;Integer, String&amp;gt; crudeCache = new HashMap&amp;lt;&amp;gt;();&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;where the final &amp;lt;&amp;gt; is a signal to javac to do its type inference magic.  I like that.  The amount of typing is not that important - I haven't measured it, but I am sure I spend more time looking reading, and thinking about code than actually typing it.  Anyway, I rely on my IDE to do a lot of boilerplate coding.  However, this syntax looks much more elegant and readable.  So, then why not go one step further and omit the &amp;lt;&amp;gt;:&lt;/p&gt;&lt;br /&gt;&lt;pre class="codeBlock"&gt;&lt;br /&gt;Map &amp;lt;Integer, String&amp;gt; crudeCache = new HashMap();&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;Can't the compiler infer type in this case too?  Unfortunately not, as this would be confused with a backwardly compatible call to a raw type constructor.  Remember that raw types really are &lt;a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/ParameterizedTypes.html#What%20is%20the%20difference%20between%20the%20unbounded%20wildcard%20instantiation%20and%20the%20raw%20type?"&gt;different&lt;/a&gt; from unbounded wildcards, so for compatibility with legacy code they need to stay.  It is a pity that the least frequent use (raw type) would be the most terse.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type inference in general is a pretty tricky problem.  Java tries on occasion in a fairly simplistic way.  Take for example&lt;/p&gt;&lt;br /&gt;&lt;pre class="codeBlock"&gt;&lt;br /&gt;List&lt;String&gt; noStrings = Collections.emptyList();&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;In that situation javac manages to infer the type from the reference assignment.  Interestingly, the implementation of the &lt;code&gt;emptyList&lt;/code&gt; method is rather crude looking.  It simply casts a raw List into the desired type and hides this chicanery behind a &lt;code&gt;@SuppressWarnings("unchecked")&lt;/code&gt;.  However, typing is not compromised - you can't ever get anything out of the list, as it is immutable and has zero size, so the apparently unsafe cast is sound.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When you not encumbered by backwards compatibility, simple syntax comes more easily.  Take for example how Scala handles this issue:&lt;/p&gt;&lt;br /&gt;&lt;pre class="codeBlock"&gt;&lt;br /&gt;val scalaMap = new HashMap[Int, String](1, "types inferred")&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;Whilst that concise syntax looks like it comes from a dynamically typed language, Scala is as statically typed as Java.  But as the type system is so well constrained, the &lt;a href="http://lamp.epfl.ch/~odersky/"&gt;designer&lt;/a&gt; (who was on the original Java generics "GJ" team) has been able to use &lt;a href="http://www.scala-lang.org/intro/inference.html"&gt;local type inference&lt;/a&gt; to provide both the generic type information, and the type of the reference declaration itself.  I am impressed by the clean look, but I think I'd miss the reference type on the left had side of the assignment as it must help when reading through the code.  Interesting to see what can be done on the jvm when you start with a clean sheet though.&lt;/p&gt;</description><link>http://serg.io/blog/2007/10/java-generics-and-constructor-type.html</link><author>noreply@blogger.com (Sergio)</author><thr:total xmlns:thr='http://purl.org/syndication/thread/1.0'>0</thr:total></item><item><guid isPermaLink='false'>tag:blogger.com,1999:blog-4414172998613045683.post-134187885845236193</guid><pubDate>Tue, 14 Aug 2007 20:03:00 +0000</pubDate><atom:updated>2007-08-15T10:23:22.072+01:00</atom:updated><category domain='http://www.blogger.com/atom/ns#'>continuous integration</category><title>Hudson - great for when you need a lightweight CI tool in a hurry</title><description>&lt;p&gt;On a recent project a colleague recommended &lt;a href="https://hudson.dev.java.net/"&gt;Hudson&lt;/a&gt; which turned out to be a very good call indeed.  The team was genuinely impressed.  Despite the tagline claiming it is an "Extensible continuous integration engine" - seriously Hudson people, drop the "engine" - that smells like a programming vapourword.  Anyway, continuous integration tools seem to be aligning themselves into two camps, &lt;a href="http://www.jetbrains.com/teamcity"&gt;big&lt;/a&gt; &lt;a href="http://cruisecontrol.sourceforge.net"&gt;fat&lt;/a&gt; &lt;a href="http://www.anthillpro.com"&gt;do everything&lt;/a&gt; ones, and &lt;a href="http://maven.apache.org/continuum"&gt;small&lt;/a&gt; &lt;a href="http://www.atlassian.com/software/bamboo"&gt;neat&lt;/a&gt; &lt;a href="http://gump.apache.org"&gt;lightweight&lt;/a&gt; ones.  Hudson is now firmly at the top of my list of the second flavour.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;So this is why it is well suited to short, dare I say agile, projects:&lt;br /&gt;&lt;ul&gt;&lt;br /&gt;&lt;li&gt;Trivial installation – the released package is a war file, so you drop it in your web container of choice and away you go.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;Configuration – going with the lightweight rapid theme, there is not much to configure.  However, Hudson scores with a really intuitive gui. No need to read the docs.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;Feature set – it had everything required for the tight timescale project I was working on – namely subversion integration (naturally), cron (&lt;a href="http://www.opensymphony.com/quartz"&gt;quartz&lt;/a&gt; I guess) style scheduling, rss feeds for build results, JUnit report rendering, and a really sweet unix tail style build output watcher.&lt;/li&gt;&lt;br /&gt;&lt;/ul&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;and this is what is not quite perfect&lt;br /&gt;&lt;ul&gt;&lt;br /&gt;&lt;li&gt;Missing a couple of features, such as support for alerting build status over chat, and delayed commit.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;Although there seems to be a decent swell of support for Hudson, and it has an open extension system, there just aren’t that many compelling extensions yet.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;No support that I could find for adding in code coverage reporting.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;A successful build shows a &lt;span style="color: blue;"&gt;blue&lt;/span&gt; rather than &lt;span style="color: red;"&gt;red&lt;/span&gt; traffic light.  That’s just confusing.  Like is blue good or bad?&lt;/li&gt;&lt;br /&gt;&lt;/ul&gt;&lt;br /&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;Really though, I am just splitting hairs. Hudson was very impressive.&lt;br /&gt;&lt;/p&gt;</description><link>http://serg.io/blog/2007/08/hudson-great-for-when-you-need.html</link><author>noreply@blogger.com (Sergio)</author><thr:total xmlns:thr='http://purl.org/syndication/thread/1.0'>0</thr:total></item><item><guid isPermaLink='false'>tag:blogger.com,1999:blog-4414172998613045683.post-7746840386685171518</guid><pubDate>Sun, 05 Aug 2007 21:00:00 +0000</pubDate><atom:updated>2007-08-03T22:03:00.220+01:00</atom:updated><category domain='http://www.blogger.com/atom/ns#'>java</category><category domain='http://www.blogger.com/atom/ns#'>spring</category><category domain='http://www.blogger.com/atom/ns#'>config</category><title>Java application config choices</title><description>&lt;p&gt;I took some good-natured jibing on my last project about the level to which I wanted to make the application configurable.  My innate pedantry meant that I was driven to throw as much of the configuration and even logic into external files.  Frameworks like Spring positively encourage this - why would you ever have a hard-coded static constant, when you can inject a value from xml?  And why stop there - why not config your Spring config files with a &lt;code&gt;&lt;a href="http://www.springframework.org/docs/api/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.html"&gt;PropertyPlaceholderConfigurer&lt;/a&gt;&lt;/code&gt;...  Well, my colleagues have made me think a bit more about this approach.  Clearly, there is some config data that no-one is quibbling about - database credentials for exmple, simply do not live hard coded into the application.  But what about other meta data?  Like say a number format pattern?  Or an SQL string?&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There are lots of choices for where metadata can reside, and picking the appropriate one is key.  Databases and properties files are great for config that often needs changing on the fly.  For example, the number format for a column in an online report.  However, they add a level of indirection during development which is anooying as the data is physically separated from the source.  They are also not well suited to refactoring, although IDEs ease some of the pain these days.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Annotations are at the other extreme as they are bound to the source.  They're appropriate for a different category of metadata - when your config drives the code's core functionality.  The classic example is a SQL (or an object query language) string which is well suited to living in annotated methods in DAOs.  There is no point having it in an easliy-changed properties file because when you change your SQL you are fundamentally impacting the behaviour.  That is not a runtime activity.  However, annotations are more verbose to create.  Moreover they are easily abused and overused resulting in bloated, messy code.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As an aside, and a great example of annotation abuse, I really don't like JUnit 4's &lt;code&gt;&lt;a href="http://www.junit.org/junit/javadoc/4.3/org/junit/Ignore.html"&gt;@Ignore&lt;/a&gt;&lt;/code&gt; - if the test is broken then fix the damn thing!  That is just encouraging sloppiness.  It is even worse than commenting out a broken test as it kind of looks official - like you somehow meant to do it.  As much as I hate to admit it, at least a chunk of commented out test code is a big red flag that shouts at you to go back and get the thing to pass.&lt;/p&gt;&lt;br /&gt;&lt;p&gt;So to sum up, the choices available in Java are increasing all the time.  Spring for example ships with more and more annotations.  In addition support is there for bean wiring by xml, properties files and programatically through the api.  In a slightly obtuse way, their new dynamic language support can be thought of as config - you can certainly use it to inject new bahaviour at runtime.  The choice can only be a good thing (I don't want to be forced to use EJB 2 deployment descriptors ever again).  It just means I've got to think more carefully about where application metadata should live and not just dump anything that looks like config into properties files.&lt;/p&gt;</description><link>http://serg.io/blog/2007/08/java-application-config-choices.html</link><author>noreply@blogger.com (Sergio)</author><thr:total xmlns:thr='http://purl.org/syndication/thread/1.0'>0</thr:total></item><item><guid isPermaLink='false'>tag:blogger.com,1999:blog-4414172998613045683.post-9180535329988123917</guid><pubDate>Tue, 15 May 2007 13:32:00 +0000</pubDate><atom:updated>2007-07-03T23:13:07.009+01:00</atom:updated><category domain='http://www.blogger.com/atom/ns#'>java</category><category domain='http://www.blogger.com/atom/ns#'>spring</category><category domain='http://www.blogger.com/atom/ns#'>testing</category><title>Easy transactional DAO JUnit tests using Spring</title><description>&lt;p&gt;This is nice quick win from the wizards at Spring.  It is all in the doco, but I thought it was worthy of a post as it is very elegant.  Unit testing a traditional DAO always gives the problem of what to do with test data that gets left in the database.  Even if individual developers have their own database schema that gets cleared down and set up each time your test suite runs, you can get problems with data from one test polluting the next.  In the worst case, your test cases start to depend on the order in which they're run.&lt;br /&gt;&lt;br /&gt;Spring provides an absurdly long named, but very handy superclass for your JUnit test cases: &lt;code&gt;&lt;a href="http://www.springframework.org/docs/api/org/springframework/test/AbstractTransactionalDataSourceSpringContextTests.html"&gt;AbstractTransactionalDataSourceSpringContextTests&lt;/a&gt;&lt;/code&gt;&lt;br /&gt;&lt;br /&gt;Writing your test cases in a subclass of this will mean that each case seamlessly runs in its own transaction.  Spring starts a transaction before the test case method is invoked, then rolls it back on completion (pass or fail).&lt;br /&gt;&lt;br /&gt;Here's an example:&lt;br /&gt;&lt;pre class="codeBlock"&gt;&lt;br /&gt;package io.serg.dao;&lt;br /&gt; &lt;br /&gt;import java.util.Collection;&lt;br /&gt;import org.junit.Test;&lt;br /&gt;import org.springframework.test.&lt;br /&gt;    AbstractTransactionalDataSourceSpringContextTests;&lt;br /&gt;import io.serg.Customer;&lt;br /&gt; &lt;br /&gt;public class CustomerDaoTest extends &lt;br /&gt;    AbstractTransactionalDataSourceSpringContextTests {&lt;br /&gt; &lt;br /&gt;   private ICustomerDao customerDao;&lt;br /&gt; &lt;br /&gt;   public void setCustomerDao(ICustomerDao customerDao) {&lt;br /&gt;      this.customerDao = customerDao;&lt;br /&gt;   }&lt;br /&gt; &lt;br /&gt;   @Test&lt;br /&gt;   public void testGetAllCustomers() {&lt;br /&gt; &lt;br /&gt;      Collection&lt;icustomer&gt; customers = this.customerDao.getAllCustomers();&lt;br /&gt;      assertNotNull(customers);&lt;br /&gt;      assertFalse(customers.isEmpty());&lt;br /&gt;   }&lt;br /&gt;}&lt;br /&gt; &lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The bean config to get this to work is very simple:&lt;br /&gt;&lt;pre class="codeBlock"&gt;&lt;br /&gt;&amp;lt;bean id="customerDao" &lt;br /&gt;   class="io.serg.dao.CustomerDao"&amp;gt;&lt;br /&gt;&lt;br /&gt;  &amp;lt;property name="dataSource" ref="dataSource"/&amp;gt;&lt;br /&gt;&amp;lt;/bean&amp;gt;&lt;br /&gt; &lt;br /&gt;&amp;lt;bean id="dataSource" &lt;br /&gt;   class="org.apache.commons.dbcp.BasicDataSource"&lt;br /&gt;   destroy-method="close"&amp;gt;&lt;br /&gt;   &lt;br /&gt;  &amp;lt;property name="driverClassName" value="${jdbc.driverClass}"/&amp;gt;&lt;br /&gt;  &amp;lt;property name="url" value="${jdbc.url}"/&amp;gt;&lt;br /&gt;  &amp;lt;property name="username" value="${jdbc.username}"/&amp;gt;&lt;br /&gt;  &amp;lt;property name="password" value="${jdbc.password}"/&amp;gt;&lt;br /&gt;&amp;lt;/bean&amp;gt;&lt;br /&gt; &lt;br /&gt;&amp;lt;bean id="transactionManager" &lt;br /&gt;   class="org.springframework.jdbc.//&lt;br /&gt;   datasource.DataSourceTransactionManager"&amp;gt;&lt;br /&gt;&lt;br /&gt;  &amp;lt;property name="dataSource" ref="dataSource"/&amp;gt;&lt;br /&gt;&amp;lt;/bean&amp;gt;&lt;br /&gt; &lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Note that we're using Spring's &lt;a href="http://www.springframework.org/docs/reference/beans.html#beans-factory-autowiring-modes-tbl"&gt;autowire by type&lt;/a&gt; to inject the transaction manager into our unit test superclass.  Still don't know what my feelings are about autowiring - my inate fear of all things magical means I'm trying to resist, but it does seem very neat in small examples like this.&lt;br /&gt;&lt;br /&gt;Clearly this is a very simple example, but more complex interactions with the database can be tested in this way, including the case where you do actually want to commit a transaction part way through a unit test (see the javadocs for &lt;code&gt;&lt;a href="http://www.springframework.org/docs/api/org/springframework/test/AbstractTransactionalSpringContextTests.html"&gt;org.springframework.test.AbstractTransactionalSpringContextTests&lt;/a&gt;&lt;/code&gt;, specifically the &lt;code&gt;&lt;a href="http://www.springframework.org/docs/api/org/springframework/test/AbstractTransactionalSpringContextTests.html#setComplete()"&gt;setComplete()&lt;/a&gt;&lt;/code&gt; method and &lt;code&gt;&lt;a href="http://www.springframework.org/docs/api/org/springframework/test/AbstractTransactionalSpringContextTests.html#setDefaultRollback(boolean)"&gt;defaultRollback&lt;/a&gt;&lt;/code&gt; property).&lt;br /&gt;&lt;br /&gt;This is a particularly sweet solution for the problem of unit testing your DAOs.  You don’t need a separate test database per developer and you can run these concurrently and let the RDBMS handle the traffic.  &lt;br /&gt;&lt;br /&gt;The principle argument against this technique is that you are still physically hitting the database so you are not just unit testing the DAO code.  But in all honesty, unless you are going to mock up your datasource and jdbc connection (very painful) there is little alternative.  In the real world, unless you go down the OR mapping route, your DAO and database are irrevicably linked.  Furthermore, Spring allows you to write very clean DAOs which do almost nothing beyond handle the interaction with a relational database, so what else is there to test anyway?</description><link>http://serg.io/blog/2007/05/easy-transactional-dao-junit-tests.html</link><author>noreply@blogger.com (Sergio)</author></item></channel></rss>